# SPDX-License-Identifier: BSD-3-Clause
from datetime import datetime
import re
import os
import textwrap
from abc                 import abstractproperty
from typing              import Any, Tuple, Union

from amaranth._toolchain import *
from amaranth.hdl        import *
from amaranth.hdl.ir     import Fragment
from amaranth.hdl.xfrm   import (
	SampleLowerer, DomainLowerer
)
from amaranth.lib.cdc    import ResetSynchronizer
from amaranth.back       import (
	rtlil, verilog
)
from amaranth.build.res  import *
from amaranth.build.run  import *
from amaranth.build      import *

import jinja2


from ..                  import __version__
from ..support           import strutils

__doc__ = '''\


'''

__all__ = (
	'OpenLANEPlatform',
)

class OpenLANEPlatform(TemplatedPlatform):
	'''
	.. note::

		See https://github.com/The-OpenROAD-Project/OpenLane#setting-up-openlane for instructions on
		setting up OpenLANE and the various PDKs.

	.. note::

		See https://openlane.readthedocs.io/en/latest/configuration/README.html#variables-information for
		more detailed information on the various ``flow_settings`` available.

	Required tools:
		* ``OpenLANE``
		* ``docker``

	Build products:
		* ``config.tcl``: OpenLANE Flow configuration
		* ``{{name}}.sdc``: Timing and clock constraints
		* ``{{name}}.v``: Design Verilog
		* ``{{name}}.debug.v``: Design debug verilog
		* ``runs/*``: OpenLANE flow output

	'''


	toolchain     = None
	openlane_root = None
	pdk_path      = None

	pdk           = abstractproperty()
	cell_library  = abstractproperty()
	flow_settings = abstractproperty()

	_common_file_templates = {
		'''build_{{name}}.sh''': r'''
			# {{autogenerated}}
			set -e{{verbose("x")}}
			[ -n "${{platform._toolchain_env_var}}" ] && . "${{platform._toolchain_env_var}}"
			if [ -z "$BASH" ]; then exec /bin/bash "$0" "$@"; fi
			{{emit_commands("sh")}}
		''',
		'''config.tcl''': r'''
			# {{autogenerated}}
			# Design Information
			set ::env(DESIGN_NAME) "{{name}}"
			std ::env(VERILOG_FILES) "/design_{{name}}/{{name}}.v"
			set ::env(SDC_FILE) "/design_{{name}}/{{name}}.sdc"
			{% if platform.default_clk %}
			# Clock Settings
            set ::env(CLOCK_PERIOD) "{{platform.default_clk_constraint.period / 1e-9}}"
            set ::env(CLOCK_PORT) "{{platform._default_clk_name}}"
            set ::env(CLOCK_NET) $::env(CLOCK_PORT)
			{% else %}
			# No clock, disable it
			set ::env(CLOCK_TREE_SYNTH) 0
			std ::env(CLOCK_PORT) ""
			{% endif %}
			# PDK Settings
			set ::env(PDK) "{{platform.pdk}}"
			set ::env(STD_CELL_LIBRARY) "{{platform.cell_library}}"
			# Design Specific Flow Settings
			{% for s, v in platform.flow_settings.items() %}
            set ::env({{s}}) {{v|tcl_escape}}
            {% endfor %}
			# Pull in PDK Settings
            set filename $::env(DESIGN_DIR)/$::env(PDK)_$::env(STD_CELL_LIBRARY)_config.tcl
            if { [file exists $filename] == 1} {
                source $filename
            }
		''',
		'''{{name}}.v''': r'''
			/* {{autogenerated}} */
			{{emit_verilog()}}
		''',
		'''{{name}}.v''': r'''
			/* {{autogenerated}} */
			{{emit_debug_verilog()}}
		''',
		'''{{name}}.sdc''': r'''
			# {{autogenerated}}
			            {% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
                {% if port_signal is not none -%}
                    create_clock -name {{port_signal.name|tcl_escape}} -period {{1000000000/frequency}} [get_ports {{port_signal.name|tcl_escape}}]
                {% else -%}
                    create_clock -name {{net_signal.name|tcl_escape}} -period {{1000000000/frequency}} [get_nets {{net_signal|hierarchy("/")|tcl_escape}}]
                {% endif %}
            {% endfor %}
            {{get_override("add_constraints")|default("# (add_constraints placeholder)")}}
		''',
	}

	_container_file_templates = {
		**_common_file_templates,
	}

	_container_required_tools = (
		'docker',
	)

	_container_command_templates = (
		r'''
		UID=$(id -u)
		GID=$(id -g)
		{{invoke_tool("docker")}}
			run
			-it
			--rm
            -v {{get_override("OpenLANE")|default(platform.openlane_root)}}:/openLANE_flow
            -v {{get_override("PDKPath")|default(platform.pdk_path)}}:/PDK
			-v {{platform.build_dir}}:/design_{{name}}
			-e PDK_ROOT=/PDK
			-u $UID:$GID
			efabless/openlane:{{get_override("openlane_version")|default("latest")}}
			sh -c "./flow.tcl -design /design_{{name}}"
		''',
	)

	_local_file_templates = {
		**_common_file_templates,
	}

	_local_required_tools = (

	)

	_local_command_templates = (
		r'''
		sh -c {{get_override("OpenLANE")|default(platform.openlane_root)}}/flow.tcl -design {{name}}
		''',
	)

	def __init__(self, *, toolchain = 'Docker'):
		super().__init__()

		assert toolchain in ('Docker', 'Local'), 'Toolchain must be either \'Docker\' or \'Local\''
		self.toolchain = toolchain

	@property
	def required_tools(self) -> list[str]:
		if self.toolchain == 'Docker':
			return self._container_required_tools
		if self.toolchain == 'Local':
			return self._local_required_tools
		assert False, f'Unknown toolchain {self.toolchain}'

	@property
	def file_templates(self) -> dict[str, str]:
		if self.toolchain == 'Docker':
			return self._container_file_templates
		if self.toolchain == 'Local':
			return self._local_file_templates
		assert False, f'Unknown toolchain {self.toolchain}'

	@property
	def command_templates(self) -> list[str]:
		if self.toolchain == 'Docker':
			return self._container_command_templates
		if self.toolchain == 'Local':
			return self._local_command_templates
		assert False, f'Unknown toolchain {self.toolchain}'

	@property
	def _default_clk_name(self) -> str:
		if self.default_clk is None:
			raise AttributeError(f'Platform \'{type(self).__name__}\' does not define a default clock')
		resource = self.lookup(self.default_clk)
		#port = self._requested[resource.name, resource.number]
		#assert isinstance(resource.ios[0], Pins)
		for res, pin, port, attrs in self._ports:
			if res == resource:
				if res.ios[0].dir == 'i':
					return pin.i.name
				else:
					return pin.o.name
		raise AssertionError(f"Platform '{type(self).__name__}' defined default clock but no matching resource")

	def build(self, *args, **kwargs):
		# Pull out `build_dir` so we can use it for our flow invocations
		self.build_dir = kwargs.get('build_dir', 'build')
		return super().build(*args, **kwargs)

	def prepare(self, elaboratable, name: str, **kwargs) -> BuildPlan:
		invalid_char = re.match(r'[^A-Za-z0-9_]', name)
		if invalid_char:
			raise ValueError(
				f'Design name \'{name!r}\' contains an invalid character \'{invalid_char.group(0)}\';'
				'only alphanumeric characters are allowed in design names.'
			)

		autogenerated = f'Automatically generated by amaranth-asic {__version__}. Do not edit'

		# assert 'ports' in kwargs, 'Must specify external port array for design'
		ports = kwargs.get('ports', list())

		fragment = Fragment.get(elaboratable, self)

		fragment = fragment.prepare(
			missing_domain = self.create_missing_domain(ports),
			**kwargs
		)

		rtlil_text, self._name_map = rtlil.convert_fragment(fragment, name)

		def emit_rtlil() -> str:
			return rtlil_text

		def emit_verilog(opts: Tuple[Any] = ()) -> str:
			return verilog._convert_rtlil_text(
				rtlil_text,
				strip_internal_attrs = True,
				write_verilog_opts = opts
			)

		def emit_debug_verilog(opts: Tuple[Any] = ()) -> str:
			return verilog._convert_rtlil_text(
				rtlil_text,
				strip_internal_attrs = False,
				write_verilog_opts = opts
			)

		def emit_commands(syntax: str) -> str:
			assert syntax == 'sh', 'Only Linux is supported at the moment'
			commands = []

			for tool in self.required_tools:
				env_var = tool_env_var(tool)
				template = {
					'sh': f'${{{env_var}}}:={tool}',
					'bat': \
						f'if [%{env_var}%] equ [""] set {env_var}=\n' \
						f'if [%{env_var}%] equ [] set {env_var}={tool}'
				}.get(syntax, None)

			commands.append(template)

			for idx, cmd_tmpl in enumerate(self.command_templates):
				cmd = render(
					cmd_tmpl,
					origin = f'<command#{idx + 1}>',
					syntax = syntax
				)

				commands.append({
					'sh': cmd,
					'bat': f'{cmd} || exit /b'
				}.get(syntax))

			return '\n'.join(commands)

		def get_override(var: str) -> Union[str, Any]:
			var_env = f'AMARANTH_ENV_{var}'
			if var_env in os.environ:
				return re.sub(r'^\"\"$', os.environ[var_env])
			elif var in kwargs:
				if isinstance(kwargs[var], str):
					return textwrap.dedent(kwargs[var]).strip()
				else:
					return kwargs[var]
			else:
				return jinja2.Undefined(name = var)

		@jinja2.contextfunction
		def invoke_tool(context, name: str) -> str:
			env_var = tool_env_var(name)
			if context.parent['syntax'] == 'sh':
				return '"${env_var}"'
			elif context.parent['syntax'] == 'bat':
				return f'%{env_var}%'
			else:
				assert False

		def options(opts: Union[str, list[str]]) -> str:
			if isinstance(opts, str):
				return opts
			else:
				return ' '.join(opts)

		def hierarchy(signal, separator: str) -> str:
			return separator.join(self._name_map[signal][1:])

		def verbose(arg: Any) -> Union[Any, jinja2.Undefined]:
			if get_override('verbose'):
				return arg
			else:
				return jinja2.Undefined( name = 'quite')

		def quiet(arg: Any) -> Union[Any, jinja2.Undefined]:
			if get_override('verbose'):
				return jinja2.Undefined( name = 'quite')
			else:
				return arg

		def render(source: str, origin: str, syntax: str = None) -> str:
			try:
				source = textwrap.dedent(source).strip()
				template: jinja2.Template = jinja2.Template(
					source,
					trim_blocks = True,
					lstrip_blocks = True,
					undefined = jinja2.StrictUndefined
				)
				template.environment.filters.update({
					'options'      : options,
					'hierarchy'    : hierarchy,
					'ascii_escape' : strutils.ascii_escape,
					'tcl_escape'   : strutils.tcl_escape,
					'tcl_quote'    : strutils.tcl_quote
				})

			except jinja2.TemplateSyntaxError as e:
				e.args = (f'{e.message} (at {origin}:{e.lineno})',)
				raise

			return template.render({
				'name'              : name,
				'platform'          : self,
				'emit_rtlil'        : emit_rtlil,
				'emit_verilog'      : emit_verilog,
				'emit_debug_verilog': emit_debug_verilog,
				'emit_commands'     : emit_commands,
				'syntax'            : syntax,
				'invoke_tool'       : invoke_tool,
				'get_override'      : get_override,
				'verbose'           : verbose,
				'quiet'             : quiet,
				'autogenerated'     : autogenerated,
				'timestamp'         : str(datetime.utcnow())
			})

		plan = BuildPlan(
			script = 'build_{name}'
		)

		for fname_tpl, fcont_tpl in self.file_templates.items():
			plan.add_file(
				render(fname_tpl, origin = fname_tpl),
				render(fcont_tpl, origin = fcont_tpl)
			)

		for fname, fcont in self.extra_files.items():
			plan.add_file(
				fname, fcont
			)

		return plan

	def create_missing_domain(self, ports: list[Any]) -> Any:
		def create_domain(name: str) -> Union[Module, None]:
			if name != 'sync' or self.default_clk is None:
				return None

			clk_i = self.request(self.default_clk).i
			ports.append(clk_i)

			m = Module()

			if self.default_rst is not None:
				rst_i = self.request(self.default_rst).i
			else:
				assert 'rst' not in map(lambda p: p.name, ports), 'wah'
				rst_i = Signal(name = 'rst')
				ports.append(rst_i)
				self.default_rst = 'rst'

			m.domains += ClockDomain('sync')
			m.d.comb += ClockSignal('sync').eq(clk_i)
			m.submodules.reset_sync = ResetSynchronizer(rst_i, domain = 'sync')

			return m

		return create_domain
